// TEMPORARILY DISABLED - OpenAI SDK removed for redesign
// This route will be reimplemented with the new AI architecture

/*
import type { ActionFunctionArgs } from '@remix-run/cloudflare';
import { json } from '@remix-run/cloudflare';
import { fetchLeadFromWorker, fetchLeadFilesFromWorker, fetchPropertyFromWorker, fetchUnitsFromWorker, runAIEvaluationToWorker, updateLeadToWorker } from '~/lib/worker-client';
import { runLeadAIEvaluation, generateSignedUrls } from '~/lib/ai.server';
import { getSiteId } from '~/lib/site.server';

export async function action({ request, params, context }: ActionFunctionArgs) {
  if (request.method !== 'POST') {
    return json({ success: false, error: 'Method not allowed' }, { status: 405 });
  }

  const { id: leadId } = params;
  if (!leadId) {
    return json({ success: false, error: 'Lead ID required' }, { status: 400 });
  }

  const siteId = getSiteId(request);
  const workerEnv = {
    WORKER_URL: context.cloudflare.env.WORKER_URL,
    WORKER_INTERNAL_KEY: context.cloudflare.env.WORKER_INTERNAL_KEY,
  };
  const bucket = context.cloudflare.env.PRIVATE_BUCKET; // Use private bucket for application files
  const openaiApiKey = context.cloudflare.env.OPENAI_API_KEY;

  if (!openaiApiKey) {
    return json(
      { success: false, error: 'OpenAI API key not configured' },
      { status: 500 }
    );
  }

  try {
    // Fetch lead
    const lead = await fetchLeadFromWorker(workerEnv, siteId, leadId);
    if (!lead) {
      return json({ success: false, error: 'Lead not found' }, { status: 404 });
    }

    // Fetch property for context
    const property = await fetchPropertyFromWorker(workerEnv, siteId, lead.propertyId);
    if (!property) {
      return json({ success: false, error: 'Property not found' }, { status: 404 });
    }

    // Get units for the property to determine rent amount
    const units = await fetchUnitsFromWorker(workerEnv, siteId);
    const propertyUnits = units.filter(u => u.propertyId === lead.propertyId);
    const rentAmount = propertyUnits.length > 0 ? propertyUnits[0].rentAmount : 0; // Use first unit's rent as typical

    // Fetch files
    const files = await fetchLeadFilesFromWorker(workerEnv, siteId, leadId);

    // Update status to evaluating
    await updateLeadToWorker(workerEnv, siteId, leadId, { status: 'ai_evaluating' });

    // Generate signed URLs for files
    const signedUrls = await generateSignedUrls(bucket, files);

    // Run AI evaluation
    const result = await runLeadAIEvaluation(openaiApiKey, {
      lead,
      files,
      propertyRent: rentAmount,
      signedUrls,
    });

    // Save evaluation using worker
    const evaluation = await runAIEvaluationToWorker(workerEnv, siteId, leadId, {
      score: result.score,
      label: result.label,
      summary: result.summary,
      riskFlags: result.risk_flags,
      recommendation: result.recommendation,
      fraudSignals: result.fraud_signals,
      modelVersion: result.model_version,
    });

    // Update lead with AI results
    await updateLeadToWorker(workerEnv, siteId, leadId, {
      status: 'ai_evaluated',
      aiScore: result.score,
      aiLabel: result.label,
    });

    return json({
      success: true,
      data: {
        evaluationId: evaluation.id,
        score: result.score,
        label: result.label,
        summary: result.summary,
        recommendation: result.recommendation,
      },
    });
  } catch (error) {
    console.error('Error running AI evaluation:', error);

    // Reset status on failure
    await updateLeadToWorker(workerEnv, siteId, leadId, { status: 'documents_received' });

    return json(
      { success: false, error: 'AI evaluation failed' },
      { status: 500 }
    );
  }
}
*/

